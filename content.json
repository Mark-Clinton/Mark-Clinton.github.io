{"meta":{"title":"Mark Clinton","subtitle":"","description":"","author":"Mark Clinton","url":"https://mark-clinton.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-10-18T01:56:33.716Z","updated":"2022-10-18T01:56:33.716Z","comments":false,"path":"/404.html","permalink":"https://mark-clinton.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-10-18T01:56:33.716Z","updated":"2022-10-18T01:56:33.716Z","comments":false,"path":"about/index.html","permalink":"https://mark-clinton.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-10-18T01:56:33.716Z","updated":"2022-10-18T01:56:33.716Z","comments":false,"path":"books/index.html","permalink":"https://mark-clinton.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-10-18T01:56:33.716Z","updated":"2022-10-18T01:56:33.716Z","comments":false,"path":"categories/index.html","permalink":"https://mark-clinton.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-10-18T01:56:33.716Z","updated":"2022-10-18T01:56:33.716Z","comments":true,"path":"links/index.html","permalink":"https://mark-clinton.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-18T01:56:33.716Z","updated":"2022-10-18T01:56:33.716Z","comments":false,"path":"repository/index.html","permalink":"https://mark-clinton.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-10-18T01:56:33.716Z","updated":"2022-10-18T01:56:33.716Z","comments":false,"path":"tags/index.html","permalink":"https://mark-clinton.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2022-10-18T01:56:33.716Z","updated":"2022-10-18T01:56:33.716Z","comments":true,"path":"2022/10/18/hello-world/","link":"","permalink":"https://mark-clinton.github.io/2022/10/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Java实现十大排序算法","slug":"Java实现十大排序算法","date":"2022-09-27T02:55:58.000Z","updated":"2022-10-18T01:56:33.716Z","comments":true,"path":"2022/09/27/Java实现十大排序算法/","link":"","permalink":"https://mark-clinton.github.io/2022/09/27/Java%E5%AE%9E%E7%8E%B0%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"1、冒泡排序 概述 原理：冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较相邻的两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 时间复杂度 平均时间复杂度：O(n2)O(n^2)O(n2) 最好情况复杂度：O(n)O(n)O(n) 最坏时间复杂度：O(n2)O(n^2)O(n2) 空间复杂度：O(1)O(1)O(1) 稳定性：稳定 一般情况下，称某个排序算法稳定，指的是当待排序序列中有相同的元素时，它们的相对位置在排序前后不会发生改变。 基础版 12345678910// 冒泡排序基础版private static void BubbleSort_v0(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; for (int j = 0; j &lt; array.length - 1 - i; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; swap(array, j, j+1); &#125; &#125; &#125;&#125; 优化版 1、利用标记判断数组是否已经有序，有序则提前终止程序。 12345678910111213// 冒泡排序优化版1(利用标记判断数组是否已经有序,有序则提前终止程序)private static void BubbleSort_v1(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; boolean sorted = true; for (int j = 0; j &lt; array.length - 1 - i; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; swap(array, j, j+1); sorted = false; &#125; &#125; if (sorted) break; &#125;&#125; 2、记录排序过程中最后一次发生交换的位置，减少比较次数。 1234567891011121314// 冒泡排序优化版2(记录最后一次交换位置，减少比较次数)private static void BubbleSort_v2(int[] array) &#123; int n = array.length - 1; do &#123; int sortedIndex = 0; for (int i = 0; i &lt; n; i++) &#123; if (array[i] &gt; array[i + 1]) &#123; swap(array, i, i + 1); sortedIndex = i; &#125; &#125; n = sortedIndex; &#125; while (n != 0);&#125; 2、选择排序 概述 原理：选择排序（Selection sort）是一种简单直观的排序算法。它的工作流程是首先从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。 时间复杂度 平均时间复杂度：O(n2)O(n^2)O(n2) 最好情况复杂度：O(n2)O(n^2)O(n2) 最坏时间复杂度：O(n2)O(n^2)O(n2) 空间复杂度：O(1)O(1)O(1) 稳定性：不稳定 基础版 1234567891011121314// 选择排序(每次选择待排序序列中的最小元素放入指定位置)private static void SelectionSort(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; int minIndex = i; for (int j = minIndex + 1; j &lt; array.length; j++) &#123; if (array[minIndex] &gt; array[j]) &#123; minIndex = j; &#125; &#125; if (minIndex != i) &#123; swap(array, i, minIndex); &#125; &#125;&#125; 3、堆排序 概述 原理：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质，即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列 时间复杂度 平均时间复杂度：O(nlog⁡n)O(n\\log{n})O(nlogn) 最好情况复杂度：O(nlog⁡n)O(n\\log{n})O(nlogn) 最坏时间复杂度：O(nlog⁡n)O(n\\log{n})O(nlogn) 空间复杂度：O(1)O(1)O(1) 稳定性：不稳定 基础版 12345678910111213141516171819202122232425262728293031323334353637// 堆排序private static void HeapSort(int[] array) &#123; int len = array.length; buildMaxHeap(array, len); while (len &gt; 0) &#123; swap(array, 0, len - 1); len--; heapify(array, 0, len); &#125;&#125;// 建立大根堆private static void buildMaxHeap(int[] array, int len) &#123; for (int i = (len / 2 - 1); i &gt;= 0; i--) &#123; heapify(array, i, len); &#125;&#125;// 恢复堆的性质private static void heapify(int[] array, int i, int len) &#123; int left = 2 * i + 1; int right = 2 * i + 2; int maxIndex = i; if (left &lt; len &amp;&amp; array[left] &gt; array[maxIndex]) &#123; maxIndex = left; &#125; if (right &lt; len &amp;&amp; array[right] &gt; array[maxIndex]) &#123; maxIndex = right; &#125; if (maxIndex != i) &#123; swap(array, i, maxIndex); heapify(array, maxIndex, len); &#125;&#125; 4、插入排序 概述 原理：插入排序，一般也被称为直接插入排序。它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。 时间复杂度 平均时间复杂度：O(n2)O(n^2)O(n2) 最好情况复杂度：O(n)O(n)O(n) 最坏时间复杂度：O(n2)O(n^2)O(n2) 空间复杂度：O(1)O(1)O(1) 稳定性：稳定 基础版 12345678910// 插入排序基础版private static void InsertionSort_v0(int[] array) &#123; for (int i = 1; i &lt; array.length; i++) &#123; int cur = i; while (cur &gt; 0 &amp;&amp; array[cur] &lt; array[cur - 1]) &#123; swap(array, cur, cur - 1); cur--; &#125; &#125;&#125; 优化版 1、将基础版中的交换操作改为挪动，减少赋值操作。 1234567891011121314// 插入排序优化版(将交换改为挪动)private static void InsertionSort_v1(int[] array) &#123; for (int i = 1; i &lt; array.length; i++) &#123; int tmp = array[i]; int cur = i; while (cur &gt; 0 &amp;&amp; tmp &lt; array[cur - 1]) &#123; array[cur] = array[cur - 1]; cur--; &#125; if (cur != i) &#123; array[cur] = tmp; &#125; &#125;&#125; 2、使用二分搜索法查询需要插入的位置，即搜索第一个大于待插入元素的位置，减少比较次数，然后统一后移需要移动元素，再进行插入。 12345678910111213141516171819202122232425262728293031/** * 适用插入排序的二分搜索 * @param array * @param index 待插入元素原始位置 * @return */private static int BinarySearch(int[] array, int index) &#123; int left = 0; int right = index; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (array[index] &lt; array[mid]) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;// 插入排序优化版(利用二分查找待插入元素需要插入的位置，然后进行元素的后移与插入)private static void InsertionSort_v2(int[] array) &#123; for (int i = 1; i &lt; array.length; i++) &#123; int tmp = array[i]; int insertIndex = BinarySearch(array, i); for (int j = i; j &gt; insertIndex; j--) &#123; array[j] = array[j - 1]; &#125; array[insertIndex] = tmp; &#125;&#125; 5、归并排序 概述 原理：归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 时间复杂度 平均时间复杂度：O(nlog⁡n)O(n\\log{n})O(nlogn) 最好情况复杂度：O(nlog⁡n)O(n\\log{n})O(nlogn) 最坏时间复杂度：O(nlog⁡n)O(n\\log{n})O(nlogn) 空间复杂度：O(n)O(n)O(n) 稳定性：稳定 基础版 1234567891011121314151617181920212223242526272829303132// 归并排序private static void MergeSort(int[] array) &#123; int[] leftTemp = new int[array.length &gt;&gt; 1]; mergersort(array,0, array.length, leftTemp);&#125;// 归并排序递归实现private static void mergersort(int[] array, int left, int right, int[] leftTemp) &#123; if (right - left &lt; 2) return; int mid = left + (right - left) / 2; mergersort(array, left, mid, leftTemp); mergersort(array, mid, right, leftTemp); merge(array, left, mid, right, leftTemp);&#125;// 归并private static void merge(int[] array, int left, int mid, int right, int[] leftTemp) &#123; int li = 0, le = mid - left; int ri = mid, re = right; int ai = left; // 备份左半侧数组 for (int i = 0; i &lt; le; i++) &#123; leftTemp[i] = array[left + i]; &#125; while (li &lt; le) &#123; if (ri &lt; re &amp;&amp; array[ri] &lt; leftTemp[li]) &#123; array[ai++] = array[ri++]; &#125; else &#123; array[ai++] = leftTemp[li++]; &#125; &#125;&#125; 6、快速排序 概述 原理：快速排序（Quicksort），快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。该算法基本步骤有三步： 从数列中挑出一个元素，称为&quot;基准&quot;（pivot） 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序 时间复杂度 平均时间复杂度：O(nlog⁡n)O(n\\log{n})O(nlogn) 最好情况复杂度：O(nlog⁡n)O(n\\log{n})O(nlogn) 最坏时间复杂度：O(n2)O(n^2)O(n2) 空间复杂度：O(log⁡n)O(\\log{n})O(logn) 稳定性：不稳定 基础版 1234567891011121314151617181920212223242526// 快速排序private static void QuickSort(int[] array) &#123; quicksort(array, 0, array.length - 1);&#125;// 快速排序的递归实现private static void quicksort(int[] array, int left, int right) &#123; if (left &gt;= right) return; // 确定轴点位置 int mid = partition(array, left, right); // 对子序列进行快速排序 quicksort(array, left, mid - 1); quicksort(array, mid + 1, right);&#125;// 分区操作，计算轴点位置private static int partition(int[] array, int left, int right) &#123; int pivot = left; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; array[right] &gt; array[pivot]) right--; while (left &lt; right &amp;&amp; array[left] &lt;= array[pivot]) left++; swap(array, left, right); &#125; swap(array, pivot, right); return right;&#125; 7、希尔排序 概述 原理：希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 时间复杂度 平均时间复杂度：O(nlog⁡n)O(n\\log{n})O(nlogn) 最好情况复杂度：O(nlog⁡2n)O(n\\log^2{n})O(nlog2n) 最坏时间复杂度：O(nlog⁡2n)O(n\\log^2{n})O(nlog2n) 空间复杂度：O(1)O(1)O(1) 稳定性：不稳定 基础版 123456789101112131415161718//希尔排序private static void ShellSort(int[] array) &#123; int length = array.length; int step = length / 2; int temp; while (step &gt; 0) &#123; for (int i = step; i &lt; length; i++) &#123; temp = array[i]; int preIndex = i - step; while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) &#123; array[preIndex + step] = array[preIndex]; preIndex -= step; &#125; array[preIndex + step] = temp; &#125; step /= 2; &#125;&#125; 8、计数排序 概述 原理：计数排序是一个非基于比较的排序算法，计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 时间复杂度 平均时间复杂度：O(n+k)O(n + k)O(n+k) 最好情况复杂度：O(n+k)O(n + k)O(n+k) 最坏时间复杂度：O(n+k)O(n + k)O(n+k) 空间复杂度：O(k)O(k)O(k) 稳定性：稳定 基础版 1234567891011121314151617181920212223// 计数排序基础版private static void CountingSort_v1(int[] array) &#123; // 找出最大值 int max = array[0]; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; // 开辟内存空间，存储每个整数出现的次数 int[] counts = new int[1 + max]; for (int i = 0; i &lt; array.length; i++) &#123; counts[array[i]]++; &#125; // 根据整数的出现次数，对整数进行排序 int sortedIndex = 0; for (int i = 0; i &lt; counts.length; i++) &#123; while (counts[i] &gt; 0) &#123; array[sortedIndex++] = i; counts[i]--; &#125; &#125;&#125; 优化版 1、优化了基础版中无法对负数进行排序的问题，优化了排序时的内存消耗，保证了稳定性。 123456789101112131415161718192021222324252627282930313233// 计数排序优化版private static void CountingSort_v1(int[] array) &#123; // 找出最值 int max = array[0]; int min = array[0]; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; if (array[i] &lt; min) &#123; min = array[i]; &#125; &#125; // 开辟内存空间，存储次数 int[] counts = new int[max - min + 1]; // 统计每个整数出现的次数 for (int i = 0; i &lt; array.length; i++) &#123; counts[array[i] - min]++; &#125; // 累加次数 for (int i = 1; i &lt; counts.length; i++) &#123; counts[i] += counts[i - 1]; &#125; // 从后往前遍历元素，将它放到有序数组中合适的位置 int[] newArray = new int[array.length]; for (int i = array.length - 1; i &gt;= 0; i--) &#123; newArray[--counts[array[i] - min]] = array[i]; &#125; // 将有序数组赋值到array for (int i = 0; i &lt; newArray.length; i++) &#123; array[i] = newArray[i]; &#125;&#125; 9、基数排序 概述 原理：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用。基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 时间复杂度 平均时间复杂度：O(n×k)O(n \\times k)O(n×k) 最好情况复杂度：O(n×k)O(n \\times k)O(n×k) 最坏时间复杂度：O(n×k)O(n \\times k)O(n×k) 空间复杂度：O(dn+d)O(dn + d)O(dn+d) 稳定性：稳定 基础版 1、基于计数排序的实现方法。 12345678910111213141516171819202122232425262728293031323334353637// 基数排序private static void RadixSort_v0(int[] array) &#123; // 找出最大值 int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; for (int divider = 1; divider &lt; max; divider *= 10) &#123; radixsort(array,divider); &#125;&#125;// 基数排序(基于计数)private static void radixsort(int[] array, int divider) &#123; // 开辟内存空间，存储次数 int[] counts = new int[10]; // 统计每个整数出现的次数 for (int i = 0; i &lt; array.length; i++) &#123; counts[array[i] / divider % 10]++; &#125; // 累加次数 for (int i = 1; i &lt; counts.length; i++) &#123; counts[i] += counts[i - 1]; &#125; // 从后往前遍历元素，将它放到有序数组中合适的位置 int[] newArray = new int[array.length]; for (int i = array.length - 1; i &gt;= 0; i--) &#123; newArray[--counts[array[i] / divider % 10]] = array[i]; &#125; // 将有序数组赋值到array for (int i = 0; i &lt; newArray.length; i++) &#123; array[i] = newArray[i]; &#125;&#125; 2、基于桶方式的实现方法。 12345678910111213141516171819202122232425262728// 基数排序(利用桶进行排序)private static void RadixSort_v1(int[] array) &#123; // 找出最大值 int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; // 桶数组 int[][] buckets = new int[10][array.length]; // 每个桶的元素数量 int[] bucketSizes = new int[buckets.length]; for (int divider = 1; divider &lt; max; divider *= 10) &#123; for (int i = 0; i &lt; array.length; i++) &#123; int bck = array[i] / divider % 10; buckets[bck][bucketSizes[bck]++] = array[i]; &#125; int index = 0; for (int i = 0; i &lt; buckets.length; i++) &#123; for (int j = 0; j &lt; bucketSizes[i]; j++) &#123; array[index++] = buckets[i][j]; &#125; bucketSizes[i] = 0; &#125; &#125;&#125; 10、桶排序 概述 原理：桶排序(Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。 时间复杂度 平均时间复杂度：O(n+k)O(n + k)O(n+k) 最好情况复杂度：O(n+k)O(n + k)O(n+k) 最坏时间复杂度：O(n2)O(n^2)O(n2) 空间复杂度：O(n+k)O(n + k)O(n+k) 稳定性：稳定 基础版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 桶排序private static void BucketSort(int[] array) &#123; int bucketSize = 5; if (array.length == 0) &#123; return; &#125; // 找出最值 int max = array[0]; int min = array[0]; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; if (array[i] &lt; min) &#123; min = array[i]; &#125; &#125; // 创建桶 int bucketCount = (int) Math.floor((max - min) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i &lt; array.length; i++) &#123; int index = (int) Math.floor((array[i] - min) / bucketSize); buckets[index] = arrAppend(buckets[index],array[i]); &#125; int index = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; // 对每个桶进行排序 Arrays.sort(bucket); for (int value : bucket) &#123; array[index++] = value; &#125; &#125;&#125;// 桶扩容，并保存数据private static int[] arrAppend(int[] bucket, int value) &#123; bucket = Arrays.copyOf(bucket,bucket.length + 1); bucket[bucket.length - 1] = value; return bucket;&#125; 简单测试 测试模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Sorts &#123; /** * 十大排序算法测试模板 */ public static void main(String[] args) &#123; // 测试数组 int[] array = &#123;5,3,23,14,4,7,9,5,6,10&#125;; // &#123;1,2,3,4,5,6,7,8,9&#125;; // 冒泡排序基础版// BubbleSort_v0(array); // 冒泡排序优化版1// BubbleSort_v1(array); // 冒泡排序优化版2// BubbleSort_v2(array); // 选择排序// SelectionSort(array); // 堆排序// HeapSort(array); // 插入排序基础版// InsertionSort_v0(array); // 插入排序优化版1// InsertionSort_v1(array); // 插入排序优化版2// InsertionSort_v2(array); // 归并排序// MergeSort(array); // 快速排序// QuickSort(array); //希尔排序// ShellSort(array); // 计数排序基础版// CountingSort_v0(array); // 计数排序优化版// CountingSort_v1(array); // 基数排序(基于计数排序)// RadixSort_v0(array); // 基数排序(基于桶)// RadixSort_v1(array); // 桶排序 BucketSort(array); System.out.println(Arrays.toString(array)); &#125; private static void swap(int[] array, int i, int j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125;&#125; 注意 以上十种算法所列出的时间复杂度与空间复杂度可能与实际算法不符，请结合具体算法实现进行分析。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://mark-clinton.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://mark-clinton.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"PyTorch环境搭建","slug":"PyTorch环境搭建","date":"2022-07-31T10:59:15.000Z","updated":"2022-10-18T01:56:33.716Z","comments":true,"path":"2022/07/31/PyTorch环境搭建/","link":"","permalink":"https://mark-clinton.github.io/2022/07/31/PyTorch%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"1. 安装anaconda 前往Anaconda官网下载个人版(Individual Edition)： 官网地址 2. 添加清华镜像源 由于PyTorch的服务器在国外，直连下载的话很慢，所以选用清华镜像源下载，步骤如下： 点击开始菜单，进入Anaconda Prompt命令行 在命令行中输入以下命令 12345678# 添加清华镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/# 添加pytorch镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/# for legacy win-64conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/conda config --set show_channel_urls yes 3. 创建新的conda虚拟环境 1234# 其中pytorch为虚拟环境名称，可自定义。后面指定安装的python版本conda create --name pytorch python=3.8# 激活 进入新环境activate pytorch 4. 安装PyTorch 可先去官网选择合适的命令，粘贴至Anaconda Prompt命令行运行： 官网地址 1conda install pytorch torchvision cudatoolkit=10.2 这里比官网的命令少了一个-c pytorch。 主要是因为-c pytorch表示指定使用pytorch channel，这个服务器位于国外，下载速度很慢，使用刚刚添加进default channel的清华镜像源可以得到一个较快的下载速度。 验证是否安装成功 在Python编译环境下输入代码并运行： 12import torch import torchvision 5. 配置Pycharm 5.1 安装Pycharm 前往Pycharm官网下载需要的版本，然后安装： 官网地址 5.2 设置Python Interpreter 在主界面菜单File-&gt;Setting-&gt;Project:xxxx-&gt;Python Interpreter。 Settings界面，点击齿轮按钮，选择Add，会弹出添加界面。 在添加界面左侧选择Conda Environment，右边选择Existing environment。 再点击...按钮添加一个已经存在的conda虚拟环境，即刚刚构建的pytorch。 选择Anaconda-&gt;envs-&gt;pytorch（刚刚创建的conda虚拟环境）-&gt;python.exe作为解释器。 注意计算机中必须安装有VC执行环境，即：Microsoft Visual C++ 2015-2019 Redistributable(x64)。 最后，PyTorch在Pycharm的环境就搭建完成了。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://mark-clinton.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PyTorch","slug":"PyTorch","permalink":"https://mark-clinton.github.io/tags/PyTorch/"}]},{"title":"Docker基础知识","slug":"Docker基础知识","date":"2022-04-14T15:04:41.000Z","updated":"2022-10-18T01:56:33.716Z","comments":true,"path":"2022/04/14/Docker基础知识/","link":"","permalink":"https://mark-clinton.github.io/2022/04/14/Docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"1. 初识Docker Docker概念 Docker 是一个开源的应用容器引擎 诞生于2013 年初，基于Go 语言实现，dotCloud 公司出品（后改名为Docker Inc） Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux 机器上 容器是完全使用沙箱机制，相互隔离 容器性能开销极低 Docker 从17.03 版本之后分为CE（Community Edition: 社区版）和EE（Enterprise Edition: 企业版） 安装Docker Docker可以运行在MAC、Windows、CentOS、UBUNTU等操作系统上，本课程基于CentOS 7 安装Docker。官网：https://www.docker.com Docker架构 镜像（Image）：Docker 镜像（Image），就相当于是一个root 文件系统。比如官方镜像ubuntu:16.04 就包含了完整的一套Ubuntu16.04 最小系统的root 文件系统。 容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库（Repository）：仓库可看成一个代码控制中心，用来保存镜像。 配置Docker 镜像加速器 默认情况下，将来从docker hub（https://hub.docker.com/）上下载docker镜像，太慢。一般都会配置镜像加速器： USTC：中科大镜像加速器（https://docker.mirrors.ustc.edu.cn） 阿里云 网易云 腾讯云 2. Docker命令 Docker进程相关命令 启动docker服务：systemctl start docker 停止docker服务：systemctl stop docker 重启docker服务：systemctl restart docker 查看docker服务状态：systemctl status docker 设置开机启动docker服务：systemctl enable docker Docker镜像相关命令 查看镜像: 查看本地所有的镜像。 12docker imagesdocker images –q # 查看所用镜像的id 搜索镜像:从网络中查找需要的镜像。 1docker search 镜像名称 拉取镜像:从Docker仓库下载镜像到本地，镜像名称格式为名称:版本号，如果版本号不指定则是最新的版本。 如果不知道镜像版本，可以去docker hub搜索对应镜像查看。 1docker pull 镜像名称 删除镜像: 删除本地镜像。 12docker rmi 镜像id # 删除指定本地镜像docker rmi `docker images -q`# 删除所有本地镜像 Docker容器相关命令 查看容器 12docker ps # 查看正在运行的容器docker ps –a # 查看所有容器 创建并启动容器 1docker run 参数 参数说明 -i：保持容器运行。通常与-t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。 -t：为容器重新分配一个伪输入终端，通常与-i 同时使用。 -d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用dockerexec 进入容器。退出后，容器不会关闭。 -it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器。 –name：为创建的容器命名。 进入容器 1docker exec 参数# 退出容器，容器不会关闭 停止容器 1docker stop 容器名称 启动容器 1docker start 容器名称 删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除 1docker rm 容器名称 查看容器信息 1docker inspect 容器名称 3. Docker容器的数据卷 数据卷概念 数据卷 数据卷是宿主机中的一个目录或文件 当容器目录和数据卷目录绑定后，对方的修改会立即同步 一个数据卷可以被多个容器同时挂载 一个容器也可以被挂载多个数据卷 数据卷作用 容器数据持久化 外部机器和容器间接通信 容器之间数据交换 配置数据卷 创建启动容器时，使用–v 参数 设置数据卷 1docker run ... –v 宿主机目录(文件):容器内目录(文件) ... 注意事项 目录必须是绝对路径 如果目录不存在，会自动创建 可以挂载多个数据卷 数据卷容器 配置数据卷容器 1.创建启动c3数据卷容器，使用 –v 参数 设置数据卷 1docker run –it --name=c3 –v /volume centos:7 /bin/bash 2.创建启动c1 c2容器，使用 –-volumes-from 参数 设置数据卷 12docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bashdocker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash 4. Docker应用部署 MySQL部署 容器内的网络服务和外部机器不能直接通信 外部机器和宿主机可以直接通信 宿主机和容器可以直接通信 当容器中的网络服务需要被外部机器访问时，可以将容器中提供服务的端口映射到宿主机的端口上。外部机器访问宿主机的该端口，从而间接访问容器的服务 这种操作称为：端口映射 搜索mysql镜像 1docker search mysql 拉取mysql镜像 1docker pull mysql:5.6 创建容器，设置端口映射、目录映射 123# 在/root目录下创建mysql目录用于存储mysql数据信息mkdir ~/mysqlcd ~/mysql 12345678docker run -id \\-p 3307:3306 \\--name=c_mysql \\-v $PWD/conf:/etc/mysql/conf.d \\-v $PWD/logs:/logs \\-v $PWD/data:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\mysql:5.6 参数说明： -p 3307:3306：将容器的 3306 端口映射到宿主机的 3307 端口。 -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。配置目录 -v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。日志目录 -v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。数据目录 **-e MYSQL_ROOT_PASSWORD=123456：**初始化 root 用户的密码。 进入容器，操作mysql 1docker exec –it c_mysql /bin/bash 使用外部机器连接容器中的mysql Tomcat部署 搜索tomcat镜像 1docker search tomcat 拉取tomcat镜像 1docker pull tomcat 创建容器，设置端口映射、目录映射 123# 在/root目录下创建tomcat目录用于存储tomcat数据信息mkdir ~/tomcatcd ~/tomcat 1234docker run -id --name=c_tomcat \\-p 8080:8080 \\-v $PWD:/usr/local/tomcat/webapps \\tomcat 参数说明： **-p 8080:8080：**将容器的8080端口映射到主机的8080端口 **-v $PWD:/usr/local/tomcat/webapps：**将主机中当前目录挂载到容器的webapps 使用外部机器访问tomcat Nginx部署 搜索nginx镜像 1docker search nginx 拉取nginx镜像 1docker pull nginx 创建容器，设置端口映射、目录映射 1234567# 在/root目录下创建nginx目录用于存储nginx数据信息mkdir ~/nginxcd ~/nginxmkdir confcd conf# 在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容vim nginx.conf 12345678910111213141516171819202122232425262728293031user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;&#125; 123456docker run -id --name=c_nginx \\-p 80:80 \\-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\-v $PWD/logs:/var/log/nginx \\-v $PWD/html:/usr/share/nginx/html \\nginx 参数说明： -p 80:80：将容器的 80端口映射到宿主机的 80 端口。 -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机当前目录下的 /conf/nginx.conf 挂载到容器的 :/etc/nginx/nginx.conf。配置目录 -v $PWD/logs:/var/log/nginx：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx。日志目录 使用外部机器访问nginx Redis部署 搜索redis镜像 1docker search redis 拉取redis镜像 1docker pull redis:5.0 创建容器，设置端口映射 1docker run -id --name=c_redis -p 6379:6379 redis:5.0 使用外部机器连接redis 1redis-cli.exe -h 192.168.149.135 -p 6379 5. Dockerfile Docker镜像原理 操作系统组成部分 进程调度子系统 进程通信子系统 内存管理子系统 设备管理子系统 文件管理子系统 网络通信子系统 作业控制子系统 Linux文件系统由bootfs和rootfs两部分组成 bootfs：包含bootloader（引导加载程序）和kernel（内核） rootfs：root文件系统，包含的就是典型Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件 不同的linux发行版，bootfs基本一样，而rootfs不同，如ubuntu，centos等 Docker镜像原理 Docker镜像是由特殊的文件系统叠加而成 最底端是bootfs，并使用宿主机的bootfs 第二层是root文件系统rootfs，称为base image 然后再往上可以叠加其他的镜像文件 统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统 一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像 当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器 思考 Docker 镜像本质是什么？ 是一个分层文件系统 Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？ Centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只有rootfs和其他镜像层 Docker 中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？ 由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的tomcat镜像大小500多MB 镜像制作 1.容器转为镜像 123docker commit 容器id 镜像名称:版本号docker save -o 压缩文件名称镜像名称:版本号docker load –i 压缩文件名称 2.dockerfile Dockerfile概念 Dockerfile是一个文本文件 包含了一条条的指令 每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像 对于开发人员：可以为开发团队提供一个完全一致的开发环境 对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了 对于运维人员：在部署时，可以实现应用的无缝移植 Dochub网址：https://hub.docker.com 1234FROMcentos:7MAINTAINER itheimaRUN yum install –y vimCMD[&quot;/bin/bash&quot;] Dockerfile关键字 关键字 作用 备注 FROM 指定父镜像 指定dockerfile基于那个image构建 MAINTAINER 作者信息 用来标明这个dockerfile谁写的 LABEL 标签 用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看 RUN 执行命令 执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,“param2”] CMD 容器启动命令 提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,“param2”] ENTRYPOINT 入口 一般在制作一些执行就关闭的容器中会使用 COPY 复制文件 build的时候复制文件到image中 ADD 添加文件 build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务 ENV 环境变量 指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value ARG 构建参数 构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数 VOLUME 定义外部可以挂载的数据卷 指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”] EXPOSE 暴露端口 定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp WORKDIR 工作目录 指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径 USER 指定执行用户 指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户 HEALTHCHECK 健康检查 指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制 ONBUILD 触发器 当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大 STOPSIGNAL 发送信号量到宿主机 该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。 SHELL 指定执行脚本的shell 指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell 练习案例 1.自定义centos7镜像。 默认登录路径为/usr 可以使用vim 案例：实现步骤 定义父镜像：FROM centos:7 定义作者信息：MAINTAINER itheima &lt;itheima@itcast.cn&gt; 执行安装vim命令：RUN yum install -y vim 定义默认的工作目录：WORKDIR/usr 定义容器启动执行的命令：CMD/bin/bash 通过dockerfile构建镜像：docker bulid –f dockerfile 文件路径 –t 镜像名称:版本 2.定义dockerfile，发布springboot项目。 案例：实现步骤 定义父镜像：FROM java:8 定义作者信息：MAINTAINER itheima &lt;itheima@itcast.cn&gt; 将jar包添加到容器：ADD springboot.jar app.jar 定义容器启动执行的命令：CMD java–jar app.jar 通过dockerfile构建镜像：docker bulid –f dockerfile 文件路径 –t 镜像名称:版本 6. Docker服务编排 服务编排 微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大。 要从Dockerfile build image 或者去dockerhub拉取image 要创建多个container 要管理这些container（启动停止删除） 服务编排：按照一定的业务规则批量管理容器。 Docker Compose Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。使用步骤： 利用Dockerfile定义运行环境镜像 使用docker-compose.yml定义组成应用的各服务 运行docker-compose up 启动应用 Docker Compose安装使用 1.安装Docker Compose 123456# Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我们以编译好的二进制包方式安装在Linux系统中。 curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose# 设置文件可执行权限 chmod +x /usr/local/bin/docker-compose# 查看版本信息 docker-compose -version 2.卸载Docker Compose 12# 二进制包方式安装的，删除二进制文件即可rm /usr/local/bin/docker-compose 3.使用docker compose编排nginx+springboot项目 创建docker-compose目录 12mkdir ~/docker-composecd ~/docker-compose 编写 docker-compose.yml 文件 1234567891011121314version: &#x27;3&#x27;services: nginx: image: nginx ports: - 80:80 links: - app volumes: - ./nginx/conf.d:/etc/nginx/conf.d app: image: app expose: - &quot;8080&quot; 创建./nginx/conf.d目录 1mkdir -p ./nginx/conf.d 在./nginx/conf.d目录下 编写itheima.conf文件 12345678server &#123; listen 80; access_log off; location / &#123; proxy_pass http://app:8080; &#125;&#125; 在~/docker-compose 目录下 使用docker-compose 启动容器 1docker-compose up 测试访问 1http://192.168.149.135/hello 7. Docker私有仓库 Docker官方的Docker hub（https://hub.docker.com）是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。 私有仓库搭建 123456789101112# 1、拉取私有仓库镜像 docker pull registry# 2、启动私有仓库容器 docker run -id --name=registry -p 5000:5000 registry# 3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;&quot;repositories&quot;:[]&#125; 表示私有仓库 搭建成功# 4、修改daemon.json vim /etc/docker/daemon.json # 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip &#123;&quot;insecure-registries&quot;:[&quot;私有仓库服务器ip:5000&quot;]&#125; # 5、重启docker 服务 systemctl restart dockerdocker start registry 将镜像上传至私有仓库 12345# 1、标记镜像为私有仓库的镜像 docker tag centos:7 私有仓库服务器IP:5000/centos:7 # 2、上传标记的镜像 docker push 私有仓库服务器IP:5000/centos:7 **从私有仓库拉取镜像 ** 12#拉取镜像 docker pull 私有仓库服务器ip:5000/centos:7 8. Docker相关概念 docker容器虚拟化与传统虚拟机比较 容器就是将软件打包成标准化单元，以用于开发、交付和部署。 容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。 容器化软件在任何环境中都能够始终如一地运行。 容器赋予了软件独立性，使其免受外在环境差异的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。 相同 容器和虚拟机具有相似的资源隔离和分配优势 不同 容器虚拟化的是操作系统，虚拟机虚拟化的是硬件 传统虚拟机可以运行不同的操作系统，容器只能运行同一类型操作系统","categories":[{"name":"笔记","slug":"笔记","permalink":"https://mark-clinton.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://mark-clinton.github.io/tags/Docker/"}]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://mark-clinton.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"深度学习","slug":"深度学习","permalink":"https://mark-clinton.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"https://mark-clinton.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://mark-clinton.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"PyTorch","slug":"PyTorch","permalink":"https://mark-clinton.github.io/tags/PyTorch/"},{"name":"Docker","slug":"Docker","permalink":"https://mark-clinton.github.io/tags/Docker/"}]}